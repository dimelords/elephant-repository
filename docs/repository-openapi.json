{
  "openapi": "3.0.0",
  "components": {
    "schemas": {
      "elephant.repository.ACLEntry": {
        "properties": {
          "permissions": {
            "description": "Permissions given to the grantee.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "uri": {
            "description": "URI that identifies the party that's granted access.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.Block": {
        "description": "Block is the building block for data embedded in documents. It is used for both content, links and metadata. Blocks have can be nested, but that's nothing to strive for, keep it simple.",
        "properties": {
          "content": {
            "description": "Content is used to embed content blocks.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Block"
            },
            "type": "array"
          },
          "contentType": {
            "description": "ContentType is used to describe the content type of the block/linked entity if it differs from the type of the block.",
            "type": "string"
          },
          "data": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Data contains block data",
            "type": "object"
          },
          "id": {
            "description": "ID is the block ID",
            "type": "string"
          },
          "links": {
            "description": "Links are used to link to other resources and documents.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Block"
            },
            "type": "array"
          },
          "meta": {
            "description": "Meta is used to embed metadata",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Block"
            },
            "type": "array"
          },
          "name": {
            "description": "Name is a name for the block. An alternative to \"rel\" when relationship is a term that doesn't fit.",
            "type": "string"
          },
          "rel": {
            "description": "Relationship describes the relationship to the document/parent entity",
            "type": "string"
          },
          "role": {
            "description": "Role is used for nuancing and qualifying relationships.",
            "type": "string"
          },
          "title": {
            "description": "Title is the title/headline of the block, typically used in the presentation of the block.",
            "type": "string"
          },
          "type": {
            "description": "Type is the type of the block",
            "type": "string"
          },
          "uri": {
            "description": "URI is used to reference another entity in a document.",
            "type": "string"
          },
          "url": {
            "description": "URL is a browseable URL for the the block.",
            "type": "string"
          },
          "uuid": {
            "description": "UUID is used to reference another Document in a block.",
            "type": "string"
          },
          "value": {
            "description": "Value is a value for the block. Useful when we want to store a primitive value.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DeleteDocumentRequest": {
        "properties": {
          "if_match": {
            "description": "IfMatch is used for optimistic locks. Set to the version that you require to be the current one for the delete to be performed.",
            "type": "integer"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta data to include with the delete record.",
            "type": "object"
          },
          "uuid": {
            "description": "UUID of the document to delete.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DeleteDocumentResponse": {
        "type": "object"
      },
      "elephant.repository.Document": {
        "description": "Document is the content",
        "properties": {
          "content": {
            "description": "Content is the content of the documen, this is essentially what gets rendered on the page when you view a document.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Block"
            },
            "type": "array"
          },
          "language": {
            "description": "Language is the language used in the document as an IETF language tag. F.ex. \"en\", \"en-UK\", \"es\", or \"sv-SE\".",
            "type": "string"
          },
          "links": {
            "description": "Links are links to other resources and entities. This could be links to categories and subject for the document, or authors.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Block"
            },
            "type": "array"
          },
          "meta": {
            "description": "Meta is the metadata for a document, this could be stuff like open graph tags and content profile information.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Block"
            },
            "type": "array"
          },
          "title": {
            "description": "Title is the title of the document, often used as the headline when the document is displayed.",
            "type": "string"
          },
          "type": {
            "description": "Type is the content type of the document.",
            "type": "string"
          },
          "uri": {
            "description": "URI identifies the document (in a more human-readable way than the UUID)",
            "type": "string"
          },
          "url": {
            "description": "URL is the browseable location of the document (if any)",
            "type": "string"
          },
          "uuid": {
            "description": "UUID is a unique ID for the document, this can be a random v4 UUID, or a URI-derived v5 UUID.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DocumentMeta": {
        "properties": {
          "acl": {
            "description": "ACL is an ACL list controlling access to the document.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.ACLEntry"
            },
            "type": "array"
          },
          "created": {
            "description": "Created timestamp is the RFC3339 timestamp for when the document was created.",
            "type": "string"
          },
          "currentVersion": {
            "description": "CurrentVersion is the last written vrsion of the document.",
            "type": "integer"
          },
          "heads": {
            "additionalProperties": {
              "$ref": "#/components/schemas/elephant.repository.Status"
            },
            "description": "Heads are the last statuses.",
            "type": "object"
          },
          "modified": {
            "description": "Modified timestamp is the RFC3339 timestamp for the last change that affected the document.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DocumentVersion": {
        "properties": {
          "created": {
            "description": "Created timestamp is the RFC3339 timestamp for when the version was created.",
            "type": "string"
          },
          "creator": {
            "description": "Creator of the version.",
            "type": "string"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta data to for the document version.",
            "type": "object"
          },
          "version": {
            "description": "Version of the document.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.EntityRef": {
        "properties": {
          "index": {
            "description": "Index is the position of the entity in an array, where applicable.",
            "type": "integer"
          },
          "kind": {
            "description": "Kind is the block type, one of \"link\", \"meta\", or \"content\".",
            "type": "string"
          },
          "name": {
            "description": "Name is the name of the entity, where applicable.",
            "type": "string"
          },
          "ref_type": {
            "description": "RefType is type of entity that's referenced, one of \"block\", \"property\", \"attribute\", \"data attribute\", or \"parameter.\"",
            "type": "string"
          },
          "rel": {
            "description": "Rel is the relationship for the entity, where applicable.",
            "type": "string"
          },
          "type": {
            "description": "Type is the type of the entity, where applicable.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetActiveSchemasRequest": {
        "type": "object"
      },
      "elephant.repository.GetActiveSchemasResponse": {
        "properties": {
          "schemas": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Schema"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetDocumentRequest": {
        "properties": {
          "lock": {
            "description": "Lock will lock the document for updates. This only affects the creation of new versions of the document statuses can still be updated.",
            "type": "boolean"
          },
          "status": {
            "description": "Status is used to fetch the version of the document references by the last status update. Can be used instead of specifying a version.",
            "type": "string"
          },
          "uuid": {
            "description": "UUID of the document to get.",
            "type": "string"
          },
          "version": {
            "description": "Version to get, omit to get latest (or use status).",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetDocumentResponse": {
        "properties": {
          "document": {
            "$ref": "#/components/schemas/elephant.repository.Document"
          },
          "version": {
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetHistoryRequest": {
        "properties": {
          "before": {
            "description": "Before is which version number we should start fetching history from, omit to start with the latest version.",
            "type": "integer"
          },
          "uuid": {
            "description": "UUID of the document to get the history for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetHistoryResponse": {
        "properties": {
          "versions": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.DocumentVersion"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetMetaRequest": {
        "properties": {
          "uuid": {
            "description": "UUID of the document to get metadata for",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetMetaResponse": {
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/elephant.repository.DocumentMeta"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetSchemaRequest": {
        "properties": {
          "name": {
            "description": "Name of the schema to get.",
            "type": "string"
          },
          "version": {
            "description": "Version of the schema to get, optional. The currently active version of the schema will be returned if no version is specified.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetSchemaResponse": {
        "properties": {
          "spec": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.ImportDirective": {
        "description": "ImportDirective can be used to preserve timestamps and authorship information from originating systems.",
        "properties": {
          "originalCreator": {
            "type": "string"
          },
          "originallyCreated": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.RegisterSchemaRequest": {
        "properties": {
          "activate": {
            "description": "Activate the registered schema immediately.",
            "type": "boolean"
          },
          "schema": {
            "$ref": "#/components/schemas/elephant.repository.Schema"
          }
        },
        "type": "object"
      },
      "elephant.repository.RegisterSchemaResponse": {
        "type": "object"
      },
      "elephant.repository.Schema": {
        "properties": {
          "name": {
            "type": "string"
          },
          "spec": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.SetActiveSchemaRequest": {
        "properties": {
          "deactivate": {
            "description": "Deactivate is used to disable a schema, activate new schema versions instead if you want to start using a new version.",
            "type": "boolean"
          },
          "name": {
            "description": "Name is the name of the schema to activate or deactivate, required.",
            "type": "string"
          },
          "version": {
            "description": "Version of the schema to activate, required when activating a new version.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.SetActiveSchemaResponse": {
        "type": "object"
      },
      "elephant.repository.Status": {
        "properties": {
          "created": {
            "description": "Created timestamp is the RFC3339 timestamp for when the statue was created.",
            "type": "string"
          },
          "creator": {
            "description": "Creator of the status.",
            "type": "string"
          },
          "id": {
            "description": "ID of the status.",
            "type": "integer"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta data for the status.",
            "type": "object"
          },
          "version": {
            "description": "Version of the document that the status refers to.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.StatusUpdate": {
        "properties": {
          "if_match": {
            "description": "IfMatch is used for optimistic locks. Set to the status id that you require to be the current one for the status to be set, or -1 to only perform the update if the status hasn't previously been set.",
            "type": "integer"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta data to include with the status update.",
            "type": "object"
          },
          "name": {
            "description": "Name of the status to set.",
            "type": "string"
          },
          "version": {
            "description": "Version to set the status for. Set to -1 to signal that the status no longer is valid for the document. Optional if part of a document update request as it then will default to the version being written.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.UpdatePermissionsRequest": {
        "properties": {
          "list": {
            "description": "Set (upsert based on URI) this list of ACL entries.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.ACLEntry"
            },
            "type": "array"
          },
          "uuid": {
            "description": "UUID of the document to update permissions for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.UpdatePermissionsResponse": {
        "type": "object"
      },
      "elephant.repository.UpdateRequest": {
        "description": "UpdateRequest creates a new document version and/or sets statuses for a document. The update is transactional will fail or succed as a whole.\n If the document fails validation an \"invalid_argument\" error will be returned with the number of errors as meta \"err_count\" and the indiviual errors as \"0\", \"1\", \"2\"... Use the Validate method to get th errors as structured data.",
        "properties": {
          "acl": {
            "description": "ACL is an ACL list controlling access to the document.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.ACLEntry"
            },
            "type": "array"
          },
          "document": {
            "$ref": "#/components/schemas/elephant.repository.Document"
          },
          "if_match": {
            "description": "IfMatch is used for optimistic locks. Set to the version that you require to be the current one for the update to be performed, or -1 to only perform the update if the document doesn't already exist.",
            "type": "integer"
          },
          "import_directive": {
            "$ref": "#/components/schemas/elephant.repository.ImportDirective"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta data to associate with the document version.",
            "type": "object"
          },
          "status": {
            "description": "Status updates to perform.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.StatusUpdate"
            },
            "type": "array"
          },
          "uuid": {
            "description": "UUID of the document to update.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.UpdateResponse": {
        "description": "UpdateResponse describes the result of an update request.",
        "properties": {
          "version": {
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.ValidateRequest": {
        "properties": {
          "document": {
            "$ref": "#/components/schemas/elephant.repository.Document"
          }
        },
        "type": "object"
      },
      "elephant.repository.ValidateResponse": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.ValidationResult"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.ValidationResult": {
        "properties": {
          "entity": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.EntityRef"
            },
            "type": "array"
          },
          "error": {
            "type": "string"
          }
        },
        "type": "object"
      }
    },
    "securitySchemes": {
      "bearer": {
        "bearerFormat": "JWT",
        "scheme": "bearer",
        "type": "http"
      }
    }
  },
  "info": {
    "title": "repository API",
    "version": "v0.0.0"
  },
  "paths": {
    "/twirp/elephant.repository.Documents/Delete": {
      "post": {
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.DeleteDocumentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.DeleteDocumentResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Delete",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Get": {
      "post": {
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetDocumentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetDocumentResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Get",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetActiveSchemas": {
      "post": {
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetActiveSchemasRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetActiveSchemasResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetActiveSchemas",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetHistory": {
      "post": {
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetHistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetHistoryResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetHistory",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetMeta": {
      "post": {
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetMetaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetMetaResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetMeta",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetSchema": {
      "post": {
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetSchemaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetSchemaResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetSchema",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/RegisterSchema": {
      "post": {
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.RegisterSchemaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.RegisterSchemaResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "RegisterSchema",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/SetActiveSchema": {
      "post": {
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.SetActiveSchemaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.SetActiveSchemaResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "SetActiveSchema",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Update": {
      "post": {
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.UpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.UpdateResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Update",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Validate": {
      "post": {
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.ValidateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.ValidateResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Validate",
        "tags": [
          "Documents"
        ]
      }
    }
  },
  "tags": [
    {
      "name": "Documents"
    }
  ]
}
