// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const acquireTXLock = `-- name: AcquireTXLock :exec
SELECT pg_advisory_xact_lock($1::bigint)
`

func (q *Queries) AcquireTXLock(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, acquireTXLock, id)
	return err
}

const createStatus = `-- name: CreateStatus :exec
select create_status(
       $1::uuid, $2::varchar(32), $3::bigint, $4::bigint,
       $5::timestamptz, $6::text, $7::jsonb
)
`

type CreateStatusParams struct {
	Uuid       uuid.UUID
	Name       string
	ID         int64
	Version    int64
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
}

func (q *Queries) CreateStatus(ctx context.Context, arg CreateStatusParams) error {
	_, err := q.db.Exec(ctx, createStatus,
		arg.Uuid,
		arg.Name,
		arg.ID,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
	)
	return err
}

const createVersion = `-- name: CreateVersion :exec
select create_version(
       $1::uuid, $2::bigint, $3::timestamptz,
       $4::text, $5::jsonb, $6::jsonb
)
`

type CreateVersionParams struct {
	Uuid         uuid.UUID
	Version      int64
	Created      pgtype.Timestamptz
	CreatorUri   string
	Meta         []byte
	DocumentData []byte
}

func (q *Queries) CreateVersion(ctx context.Context, arg CreateVersionParams) error {
	_, err := q.db.Exec(ctx, createVersion,
		arg.Uuid,
		arg.Version,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
		arg.DocumentData,
	)
	return err
}

const getDocumentACL = `-- name: GetDocumentACL :many
SELECT uuid, uri, permissions FROM acl WHERE uuid = $1
`

type GetDocumentACLRow struct {
	Uuid        uuid.UUID
	Uri         string
	Permissions pgtype.Array[string]
}

func (q *Queries) GetDocumentACL(ctx context.Context, uuid uuid.UUID) ([]GetDocumentACLRow, error) {
	rows, err := q.db.Query(ctx, getDocumentACL, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentACLRow
	for rows.Next() {
		var i GetDocumentACLRow
		if err := rows.Scan(&i.Uuid, &i.Uri, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentForUpdate = `-- name: GetDocumentForUpdate :one
SELECT uri, current_version FROM document
WHERE uuid = $1
FOR UPDATE
`

type GetDocumentForUpdateRow struct {
	Uri            string
	CurrentVersion int64
}

func (q *Queries) GetDocumentForUpdate(ctx context.Context, uuid uuid.UUID) (GetDocumentForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getDocumentForUpdate, uuid)
	var i GetDocumentForUpdateRow
	err := row.Scan(&i.Uri, &i.CurrentVersion)
	return i, err
}

const getDocumentHeads = `-- name: GetDocumentHeads :many
SELECT name, id
FROM status_heads 
WHERE uuid = $1
`

type GetDocumentHeadsRow struct {
	Name string
	ID   int64
}

func (q *Queries) GetDocumentHeads(ctx context.Context, uuid uuid.UUID) ([]GetDocumentHeadsRow, error) {
	rows, err := q.db.Query(ctx, getDocumentHeads, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDocumentHeadsRow
	for rows.Next() {
		var i GetDocumentHeadsRow
		if err := rows.Scan(&i.Name, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatuses = `-- name: GetStatuses :many
SELECT uuid, name, id, version, created, creator_uri, meta
FROM document_status
WHERE uuid = $1 AND name = $2 AND ($3 = 0 OR id < $3)
ORDER BY id DESC
LIMIT $4
`

type GetStatusesParams struct {
	Uuid    uuid.UUID
	Name    string
	Column3 interface{}
	Limit   int32
}

func (q *Queries) GetStatuses(ctx context.Context, arg GetStatusesParams) ([]DocumentStatus, error) {
	rows, err := q.db.Query(ctx, getStatuses,
		arg.Uuid,
		arg.Name,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentStatus
	for rows.Next() {
		var i DocumentStatus
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVersions = `-- name: GetVersions :many
SELECT uuid, name, id, version, created, creator_uri, meta
FROM document_status
WHERE uuid = $1 AND name = $2 AND ($3 = 0 OR id < $3)
ORDER BY id DESC
LIMIT $4
`

type GetVersionsParams struct {
	Uuid    uuid.UUID
	Name    string
	Column3 interface{}
	Limit   int32
}

func (q *Queries) GetVersions(ctx context.Context, arg GetVersionsParams) ([]DocumentStatus, error) {
	rows, err := q.db.Query(ctx, getVersions,
		arg.Uuid,
		arg.Name,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentStatus
	for rows.Next() {
		var i DocumentStatus
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notify = `-- name: Notify :exec
SELECT pg_notify($1::text, $2::text)
`

type NotifyParams struct {
	Channel string
	Message string
}

func (q *Queries) Notify(ctx context.Context, arg NotifyParams) error {
	_, err := q.db.Exec(ctx, notify, arg.Channel, arg.Message)
	return err
}
