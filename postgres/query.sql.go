// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCurrentVersion = `-- name: GetCurrentVersion :one
SELECT
        v.uuid, v.version, v.hash, v.title, v.type, v.language,
        v.created, v.creator_uri, v.meta, v.document_data, v.archived
FROM document AS d
     INNER JOIN document_version AS v ON
           v.uuid = d.uuid AND v.version = d.current_version
WHERE d.uuid = $1
`

func (q *Queries) GetCurrentVersion(ctx context.Context, uuid pgtype.UUID) (DocumentVersion, error) {
	row := q.db.QueryRow(ctx, getCurrentVersion, uuid)
	var i DocumentVersion
	err := row.Scan(
		&i.Uuid,
		&i.Version,
		&i.Hash,
		&i.Title,
		&i.Type,
		&i.Language,
		&i.Created,
		&i.CreatorUri,
		&i.Meta,
		&i.DocumentData,
		&i.Archived,
	)
	return i, err
}

const getDocumentACL = `-- name: GetDocumentACL :many
SELECT uuid, uri, permissions FROM acl WHERE uuid = $1
`

func (q *Queries) GetDocumentACL(ctx context.Context, uuid pgtype.UUID) ([]Acl, error) {
	rows, err := q.db.Query(ctx, getDocumentACL, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Acl
	for rows.Next() {
		var i Acl
		if err := rows.Scan(&i.Uuid, &i.Uri, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatuses = `-- name: GetStatuses :many
SELECT uuid, name, id, version, hash, created, creator_uri, meta
FROM document_status
WHERE uuid = $1 AND name = $2 AND ($3 = 0 OR id < $3)
ORDER BY id DESC
LIMIT $4
`

type GetStatusesParams struct {
	Uuid    pgtype.UUID
	Name    string
	Column3 interface{}
	Limit   int32
}

func (q *Queries) GetStatuses(ctx context.Context, arg GetStatusesParams) ([]DocumentStatus, error) {
	rows, err := q.db.Query(ctx, getStatuses,
		arg.Uuid,
		arg.Name,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentStatus
	for rows.Next() {
		var i DocumentStatus
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.ID,
			&i.Version,
			&i.Hash,
			&i.Created,
			&i.CreatorUri,
			&i.Meta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDocumentStatus = `-- name: InsertDocumentStatus :exec
INSERT INTO document_status(uuid, name, id, hash, created, creator_uri, meta)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type InsertDocumentStatusParams struct {
	Uuid       pgtype.UUID
	Name       string
	ID         int64
	Hash       []byte
	Created    pgtype.Timestamptz
	CreatorUri string
	Meta       []byte
}

func (q *Queries) InsertDocumentStatus(ctx context.Context, arg InsertDocumentStatusParams) error {
	_, err := q.db.Exec(ctx, insertDocumentStatus,
		arg.Uuid,
		arg.Name,
		arg.ID,
		arg.Hash,
		arg.Created,
		arg.CreatorUri,
		arg.Meta,
	)
	return err
}
